using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace levelparser
{
    class Program
    {
        private static Random random;

        static void Main(string[] args)
        {
            var randomSeed = 20171219;
            random = new Random(randomSeed);

            var levels = new List<Level>();
            foreach (var img in Directory.GetFiles(".", "*.png"))
            {
                // Open image
                var bmp = (Bitmap)Image.FromFile(img);
                byte xmax = 0, ymax = 0;

                // Getting the size 
                for (byte x = 1; x <= bmp.Width; x++)
                    for (byte y = 1; y <= bmp.Height; y++)
                        if (bmp.GetPixel(x - 1, y - 1).A != 0)
                        {
                            if (x > xmax)
                                xmax = x;

                            ymax = y;
                        }

                var lvl = new Level(Path.GetFileNameWithoutExtension(img).ToUpper(), xmax, ymax);

                var pieceMap = new int[xmax, ymax];

                // Mark pieces
                var currentPiece = 0;
                for (var y = 0; y < ymax; y++)
                    for (var x = 0; x < xmax; x++)
                        if (pieceMap[x, y] == 0)
                            MarkPieceBlocksStartingFrom(++currentPiece, x, y, ref pieceMap, bmp);

                Console.WriteLine(img);
                Print2DArray(pieceMap);
                /*Console.Read();*/

                // List unique pieces
                for (var piece = 1; piece <= currentPiece; piece++)
                {
                    byte pxmin = xmax, pxmax = 0, pymin = ymax, pymax = 0;

                    for (byte y = 0; y < ymax; y++)
                        for (byte x = 0; x < xmax; x++)
                            if (pieceMap[x, y] == piece)
                            {
                                if (x > pxmax)
                                    pxmax = x;
                                if (x < pxmin)
                                    pxmin = x;
                                if (y > pymax)
                                    pymax = y;
                                if (y < pymin)
                                    pymin = y;
                            }

                    // Generate stream
                    var pieceParts = new List<bool>();

                    for (var y = pymin; y <= pymax; y++)
                        for (var x = pxmin; x <= pxmax; x++)
                            pieceParts.Add(pieceMap[x, y] == piece);

                    var length = (int)Math.Ceiling((double)pieceParts.Count / 8) * 8;
                    var bytes = new byte[length / 8];
                    new BitArray(pieceParts.ToArray()).CopyTo(bytes, 0);

                    // Add piece
                    lvl.Pieces.Add(new Piece((byte)(1 + pxmax - pxmin), pxmin, pymin, bytes));
                }
                levels.Add(lvl);
            }

            // Generate output
            var output = new List<string>();
            var pieces = new List<byte[]>();

            foreach (var level in levels)
                foreach (var piece in level.Pieces) 
                {
                    var data = piece.GetBytes();

                    // Only add unique pieces
                    if (!pieces.Contains(data, new ArrayComparer()))
                        pieces.Add(data);
                }

            // Output pieces
            var piecesIndices = new List<int> { 0 };
            var piecesDataChunks = new List<string> { "" };
            var i = 0;

            foreach (var piece in pieces)
            {
                piecesDataChunks.Add(string.Join(", ", piece) + ", /* Piece "+ piecesIndices.Count + " */");

                i += piece.Length;
                piecesIndices.Add(i);
            }

            output.Add("// Generated by: " + Assembly.GetExecutingAssembly().FullName);
            output.Add("// Date: " + DateTime.Now);
            output.Add("// Seed: " + randomSeed);
            output.Add("");
            output.Add("// Total pieces: " + pieces.Count);
            output.Add("const byte PROGMEM piecesBytes[] = { " + string.Join(Environment.NewLine,piecesDataChunks)+Environment.NewLine+"};");
            output.Add("const int PROGMEM pieces[] = { " + string.Join(", ", piecesIndices) + " };");

            var levelsIndices = new List<int> { 0 };
            var levelsDataChunks = new List<string> { "" };
            i = 0;

            foreach (var level in levels)
            {
                var b = GetBytesFromLevel(level, pieces);
                levelsDataChunks.Add(string.Join(", ",b) + ", /* Level " + levelsIndices.Count + " */");
                i += b.Count();
                levelsIndices.Add(i);
            }
            //output.Add($"{level.Name}={{{level.Width},{level.Height},{level.Pieces.Count},{{{string.Join(",",GetPieces(level.Pieces,pieces))}}}}}");

            output.Add("");
            output.Add("// Levels");
            output.Add("const byte totalLevels = " + levels.Count + ";");
            output.Add("const byte PROGMEM levelsBytes[] = { " + string.Join(Environment.NewLine, levelsDataChunks) + " };");
            output.Add("const int PROGMEM levels[] = { " + string.Join(", ", levelsIndices) + " };");

            File.WriteAllLines("levels.h", output);
        }

        private static IEnumerable<byte> GetBytesFromLevel(Level level, List<byte[]> pieces)
        {
            var b = new List<byte>
            {
                level.Width,
                level.Height
            };
            foreach (var p in level.Pieces.OrderBy(x => random.Next())) // Scramble
                b.Add(FindIndex(p, pieces));

            return b;
        }

        private static byte FindIndex(Piece p, List<byte[]> pieces)
        {
            var pieceBytes = p.GetBytes();
            for (byte b = 0; b < Math.Min(byte.MaxValue, pieces.Count); b++)
                if (pieceBytes.Length == pieces[b].Length)
                {
                    var matches = 0;
                    for (var i = 0; i < pieceBytes.Length; i++)
                        if (pieceBytes[i] != pieces[b][i])
                            break;
                        else
                            matches++;

                    if (matches == pieceBytes.Length)
                        return b;
                }

            throw new IndexOutOfRangeException();
        }

        class ArrayComparer : EqualityComparer<byte[]>
        {
            public override bool Equals(byte[] x, byte[] y)
            {
                if (x.Length == y.Length)
                {
                    for (var i = 0; i < x.Length; i++)
                        if (x[i] != y[i])
                            return false;

                    return true;
                }
                return false;
            }

            public override int GetHashCode(byte[] obj)
            {
                throw new NotImplementedException();
            }
        }

        private static IEnumerable<int> GetPieces(List<Piece> piecesInLevel, List<byte[]> piecesDataChunks)
        {
            foreach (var piece in piecesInLevel)
                yield return piecesDataChunks.IndexOf(piece.GetBytes());
        }

        public static void Print2DArray<T>(T[,] matrix)
        {
            for (int j = 0; j < matrix.GetLength(1); j++)
                {
                for (int i = 0; i < matrix.GetLength(0); i++)
                    Console.Write(matrix[i, j] + "\t");
                Console.WriteLine();
            }
        }



        private static void MarkPieceBlocksStartingFrom(int current, int x, int y, ref int[,] pieceMap, Bitmap bmp)
        {
            var referenceColor = bmp.GetPixel(x, y);
            RecursiveMark(referenceColor, current, x, y, ref pieceMap, bmp);
        }

        private static void RecursiveMark(Color referenceColor, int current, int x, int y, ref int[,] pieceMap, Bitmap bmp)
        {
            //Console.WriteLine("Checking: " + x + "," + y);

            if (x < 0 || y < 0 || x >= pieceMap.GetLength(0) || y >= pieceMap.GetLength(1))
                return; // Nothing to do, out of bounds

            if (pieceMap[x, y] != 0)
                return; // Already processed

            //Console.WriteLine("-> Checking: " + x + "," + y);

            if (bmp.GetPixel(x, y) == referenceColor)
            {
                pieceMap[x, y] = current;

                // Check the sides
                RecursiveMark(referenceColor, current, x - 1, y, ref pieceMap, bmp);
                RecursiveMark(referenceColor, current, x + 1, y, ref pieceMap, bmp);
                RecursiveMark(referenceColor, current, x, y - 1, ref pieceMap, bmp);
                RecursiveMark(referenceColor, current, x, y + 1, ref pieceMap, bmp);
            }
        }
    }

    internal class Level
    {
        public Level(string v, byte xmax, byte ymax)
        {
            Name= v;
            Width = xmax;
            Height = ymax;
            Pieces = new List<Piece>();
        }

        public List<Piece> Pieces { get; private set; }
        public string Name { get; private set; }
        public byte Width { get; private set; }
        public byte Height { get; private set; }
    }

    internal class Piece
    {
        public Piece(byte width, byte x, byte y, byte[] bytes)
        {
            Width = width;
            X = x;
            Y = y;
            Data = bytes;
        }

        public byte Width { get; private set; }
        public byte X { get; private set; }
        public byte Y { get; private set; }
        public byte[] Data { get; private set; }

        internal byte[] GetBytes()
        {
            var b = new byte[1 + Data.Length];
            b[0] = Width;
            Data.CopyTo(b, 1);

            return b;
        }
    }
}
